# Chap 8. 객체 참조, 가변성, 재활용

------------

  모든 파이썬 객체는 정체성, 자료형, 값을 가지고 있다. 코드가 실행되는 동안 객체는 값만 바뀔 뿐이다.

변수 두 개가 동일한 값을 가진 불변 객체(a==b가 참이다)를 가리키고 있다면, 변수가 각각의 사본을 가리키고 있는지 아니면 동일 객체에 대한 별명인지는 중요하지 않다. 어쨌든 불변 객체는 변하지 않기 때문이다. 단, 튜플이나 frozenset 등의 **불변 컬렉션**인 경우는 예외다.불변 컬렉션이 가변 항목에 대한 참조를 담고 있는 경우, 가변 항목의 값이 바뀔 때 컬렉션의 값도 바뀐다. 사실 이런 상황이 흔한 것은 아니다. 불변 컬렉션에서 바뀌지 않는 것은 그 안에 들어 있는 객체의 정체성이며, 불변 컬렉션이 참조하는 가변 객체가 바뀌는 것을 막지 않는다.

  변수가 참조를 담고 있다는 사실은 파이썬 프로그래밍에서 실제로 다음과 같은 영향을 미친다.

- 단순 할당문은 사본을 생성하지 않는다. 
- +=나, *= 같은 복합 할당 연산자는 왼쪽 변수가 불변 객체에 바인딩되어 있을 때는 객체를 새로 생성하고, 가변 객체에 바인딩되어 있을 때는 기존 객체를 변경한다.
- 기존 변수에 새로운 값을 할당하면 기존에 바인딩 되어있던 객체를 변경하지 않는다. 이것을 재바인딩(rebinding)이라고 하며, 변수가 새로운 객체에 바인딩 되도록 만든다. 그 변수가 기존 객체를 참조하는 마지막 참조였다면, 기존 객체는 가비지 컬렉트된다.
- 함수 매개변수는 별명으로 전달되므로, 함수는 인수로 전달받은 가변 객체를 모두 변경할 수 있다. 가변 객체의 변경을 막으려면 함수 안에서 사본을 생성하거나, 리스트 대신 튜플을 전달하는 등 불변 객체를 사용해야 한다.
- 함수 매개변수의 기본값으로 가변 객체를 사용하는 것은 위험하다. 매개변수를 변경하면 기본 값이 변경되어 이 기본값을 사용하는 함수가 나중에 호출될 때 영향을 받기 때문이다.

CPython에서 객체는 참조수가 0이 되는 순간 제거된다. 그리고 순환 참조 그룹을 형성해서 외부에서 참조할 수 없을 때도 제거된다. 때로는 객체의 참조 수를 증가시키지 않으면서 객체를 참조해야 하는 경우가 있다. 자신의 객체를 모두 추적하려는 클래스의 경우가 이에 해당한다. 이 때는 약한 참조를 사용한다. 약한 참조는 `weakref` 모듈의 `WeakValueDictionary`, `WeakKeyDictionary`, `WeakSet` 컬렉션 및 `finalize()` 함수의 기반이 되는 메커니즘이다.



## 8.2 정체성, 동질성, 별명

별명(aliasing) : 아래의 코드 안에서 lewis와 charles는 별명이다. 두 변수가 동일 객체에 바인딩되어있다. 한편, alex는 charles에 대한 별명이 아니다. 이 두 변수는 서로 다른 객체에 바인딩되어 있다. alex에 바인딩 된 객체와 charles에 바인딩된 객체가 동일한 값을 갖고 있으므로 == 연산자 (동치 연산자)에 의해 동일하다고 판단되지만, 정체성은 다르다.

```python
charles = {'name': 'Charles L. Dodgson', 'born': 1832}
lewis = charles
lewis is charles

id(charles), id(lewis)

lewis['balance'] = 950
charles
```

```python
alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}
alex == charles
# True
alex is not charles
# True
```



## 8.3 기본 복사는 얕은 복사

- copy()와 deepcopy()의 비교

```python
import copy
bus1 = Bus(['Alice', 'Bill', 'Claire', 'David'])
bus2 = copy.copy(bus1)
bus3 = copy.deepcopy(bus1)

id(bus1), id(bus2), id(bus3)
# (4301498296, 4301499416, 4301499752)
bus1.drop('Bill')

bus2.passengers
# ['Alice', 'Claire', 'David']

id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)
# (4302658568, 4302658568, 4302657800)

bus3.passengers
# ['Alice', 'Bill', 'Claire', 'David'] 
```

일반적으로 깊은 사본을 만드는 일은 간단하지 않다. 객체 안에 순환 참조가 있으면 단순한 알고리즘은 무한 루프에 빠질 수 있다. deepcopy() 함수는 순환 참조를 제대로 처리하기 위해 이미 복사한 객체데 대한 참조를 기억하고 있다.



## 8.4 참조로서의 함수 매개변수

파이썬은 공유로 호출하는 매개변수 전달방식만 지원한다. 공유로 호출한다는 말은 함수의 각 매개변수가 인수로 전달받은 각 참조의 사본을 받는다는 의미다. 즉, 함수 안의 매개변수는 실제 인수의 별명이 된다.

- 가변형이 기본값이 될 때의 위험성을 보여주는 간단한 클래스

```python
class HauntedBus:

 	def __init__(self, passengers=[]):
 		self.passengers = passengers
        
 	def pick(self, name):
 		self.passengers.append(name)

 	def drop(self, name):
 		self.passengers.remove(name)
```

명시적인 승객 리스트로 초기화되지 않은 Bus 객체들이 승객 리스트를 공유하게 되는 문제가 발생한다.



## 8.5 del과 가비지 컬렉션

del 명령은 이름을 제거하는 것이지, 객체를 제거하는 것이 아니다. del의 명령 결과로 객체가 가비지 컬렉트될 수 있지만, 제거된 변수가 객체를 참조하는 최후의 변수거나 객체에 도달할 수 없을 때만 가비지 컬렉트된다. 변수를 다시 바인딩해도 객체에 대한 참조 카운트(reference count)를 0으로 만들어 객체가 제거될 수 있다.

## 8.6 약한 참조

객체가 메모리에 유지되거나 유지되지 않도록 만드는 것은 참조의 존재여부다. 객체 참조 카운트가 0이 되면 가비지 컬렉터는 해당 객체를 제거한다. 그러나 불필요하게 객체를 유지시키지 않으면서 객체를 참조할 수 있으면 도움이 되는 경우가 종종 있다. 캐시가 그 대표적인 경우

약한 참조는 참조 카운트를 증가시키지 않고 객체를 참조한다. 참조의 대상인 객체를 참조대상이라고 한다. 

```python
>>> import weakref
>>> a_set = {0, 1}
>>> wref = weakref.ref(a_set)
>>> wref
<weakref at 0x100637598; to 'set' at 0x100636748>
>>> wref()
{0, 1}
>>> a_set = {2, 3, 4}
>>> wref()
{0, 1}
>>> wref() is None
False
>>> wref() is None
True
```

- 약한 참조의 한계
    - 모든 파이썬 객체가 약한 참조의 대상이 될수 있는 것이 아니다. set 객체는 참조대상이 될 수 없다. int 와 tuple객체는 클래스를 상속해도 약한 참조의 대상이 될 수 없다.



## 8.7 파이썬의 특이한 불변형 처리법

- 다른 튜플로 생성한 튜플은 사실 동일한 튜플이다.

```python
>>> t1 = (1, 2, 3)
>>> t2 = tuple(t1)
>>> t2 is t1
True
>>> t3 = t1[:]
>>> t3 is t1
True
```



- 스트링 리터럴은 공유 객체를 생성하기도 한다.

```python
>>> t1 = (1, 2, 3)
>>> t3 = (1, 2, 3) 
>>> t3 is t1 
False
>>> s1 = 'ABC'
>>> s2 = 'ABC' 
>>> s2 is s1 
True
```